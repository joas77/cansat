<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ChibiOS/RT: ChibiOS RTOS libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ChibiOS/RT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ChibiOS RTOS libraries </div>  </div>
</div>
<div class="contents">
<div class="textblock"><center>William Greiman</center> <center>8 Feb 2013</center><h2><a class="anchor" id="Intro"></a>
Introduction</h2>
<p>This package contains versions of the ChbiOS/RT RTOS for AVR Arduinos, the Due Arduino, and Teensy 3.0.</p>
<p>Information about Teensy 3.0 can be found here:</p>
<p><a href="http://www.pjrc.com/teensy/">http://www.pjrc.com/teensy/</a></p>
<p>These systems are packaged as the Arduino libraries ChibiOS_ARM and ChibiOS_AVR. In addition the SdFat library for ARM/AVR is included.</p>
<p>SdFat is a FAT16/FAT32 file system for SD cards. More information is available here:</p>
<p><a href="http://code.google.com/p/sdfatlib/">http://code.google.com/p/sdfatlib/</a></p>
<p>And beta versions are here:</p>
<p><a href="http://code.google.com/p/beta-lib/">http://code.google.com/p/beta-lib/</a></p>
<p>The documentation for ChibiOS/RT is located here:</p>
<p><a href="http://www.chibios.org/dokuwiki/doku.php?id=start">http://www.chibios.org/dokuwiki/doku.php?id=start</a></p>
<p>Also please explore the above tabs.</p>
<h2><a class="anchor" id="multithread"></a>
Threadsafe and reentrant functions</h2>
<p>If this is your first exposure to a RTOS you will likely feel some pain.</p>
<p>You may want to start using ChibiOS in cooperative mode. See the chCoop.ino example below. In this mode preemptive context switches are disabled for threads of the same priority.</p>
<p>The normal Arduino environment is single-threaded so code does not need to be reentrant or threadsafe. With a preemptive RTOS, the same resources may be accessed concurrently by several threads.</p>
<p>Many arduino libraries and functions are not reentrant or threadsafe.</p>
<p>To protect resource integrity, code written for multithreaded programs must be reentrant and threadsafe.</p>
<p>Reentrance and thread safety are both related to the way that functions handle resources. Reentrance and thread safety are separate concepts: a function can be either reentrant, threadsafe, both, or neither.</p>
<p>A reentrant function does not hold static data over successive calls, nor does it return a pointer to static data. A reentrant function must not call non-reentrant functions.</p>
<p>A threadsafe function protects shared resources from concurrent access by locks. Only one thread can be executing at a time.</p>
<p>The dynamic memory functions malloc and free are not threadsafe. This means that libraries like String and SD.h are not thread safe since they use malloc/free.</p>
<p>SdFat does not use malloc but is not threadsafe. Notice that I put all access to the SD in the low priority loop thread to avoid problems.</p>
<h2><a class="anchor" id="rtosprobs"></a>
Blocking, deadlocks and priority</h2>
<p>You must not use Arduino delay() in other than the lowest priority task. delay() will block all lower priority threads.</p>
<p>Two of the most common design problems for embedded developers are the deadlock and the priority inversion problem. You should start with very simple designs to avoid these subtle problems.</p>
<h2><a class="anchor" id="errorcodes"></a>
Crash error codes</h2>
<p>I have installed simple exception error handlers for three ISR vectors. If an execution fault causes one of these exception, I blink the pin 13 LED. The codes are:</p>
<p>Hard fault - blink one short flash every two seconds</p>
<p>Bus fault - blink two short flashes every two seconds</p>
<p>Usage fault - blink three short flashes every two seconds</p>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<p>There are a number examples in each RTOS library. </p>
<h3><a class="anchor" id="chBlink"></a>
Two Thread Blink</h3>
<p>The chBlink.ino example demonstrates thread definition, semaphores, and thread sleep.</p>
<p>Thread 1 waits on a semaphore and turns the LED off when signalled by thread 2.</p>
<p>Thread 2 turns the LED on, sleeps for a period, signals thread 1 to turn the LED off, and sleeps for another period.</p>
<h3><a class="anchor" id="blink_print"></a>
Blink Print Example</h3>
<p>The blink/print example in each library is chBlinkPrint.ino.</p>
<p>Each of the blink/print examples has three threads. A high priority thread blinks an LED, a medium priority thread prints a counter every second, and a low priority thread increments the counter.</p>
<p>The print thread also checks Serial for input. If the input is available, the print thread will display stack usage information for each thread and stop the blink thread.</p>
<p>An interesting experiment is to observe the nonatomic behavior of incrementing count in <a class="el" href="_chibi_o_s___a_v_r_8c.html#afe461d27b9c48d5921c00d521181f12f">loop()</a>.</p>
<p>Comment out noInterrupts() and interrupts() like this:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//  noInterrupts();</span>
  count++;
<span class="comment">//  interrupts();</span>
</pre></div><p>You will then see occasional large counts when the print thread tries to zero count while the <a class="el" href="_chibi_o_s___a_v_r_8c.html#afe461d27b9c48d5921c00d521181f12f">loop()</a> thread is incrementing count.</p>
<h3><a class="anchor" id="context_switch"></a>
Semaphore Context Switch Time</h3>
<p>You need an oscilloscope to run this example. This example is chContextTime.ino.</p>
<p>To run this example, connect the scope to pin 13. You will see two pulses. Measure difference in time between first pulse with no context switch and the second pulse started in ledControl and ended in ledOffTask.</p>
<p>The difference is the time for the semaphore and a context switch.</p>
<h3><a class="anchor" id="coop_schedule"></a>
Cooperative Scheduling Example</h3>
<p>ChibiOS/RT uses cooperative scheduling when CH_TIME_QUANTUM is set to zero. This disables preemption for threads with equal priority and the round robin becomes cooperative. Note that higher priority threads can still preempt, the kernel is always preemptive.</p>
<p>The chCoop.ino example illustrates this feature.</p>
<p>Note that is is not necessary to protect count or maxDelay in this example since a context switch can not happen while these variables are accessed.</p>
<h3><a class="anchor" id="data_share"></a>
Data Sharing Using a Mutex</h3>
<p>The chDataSharing.ino example illustrates thread safe data sharing between two threads.</p>
<p>Thread 1 reads a sensor into temp variables. Thread 1 calls chMtxLock() to prevent Thread 2 from accessing the shared data, and copies the temp variables to the shared area, and then unlocks access to the shared area.</p>
<p>Thread 2 runs every second. Thread 2 locks the shared data, copies the shared values to temp variables, and unlocks access to the shared area.</p>
<p>Thread 2 then prints the temp values and unused stack stats.</p>
<h3><a class="anchor" id="fifo_logger"></a>
FIFO Data Logger</h3>
<p>The fast data logger example is chFifoDataLogger.ino. This example require connection to an SD socket.</p>
<p>Two semaphores are used to implement a FIFO for data records. This uncouples the data acquisition task from the SD write task. SD card have unpredictable write latencies that can be over 100 milliseconds.</p>
<p>You need a quality SD card to avoid data overrun errors. Overruns could be avoided by allocating more memory to the buffer queue.</p>
<p>This example logs a counter as dummy data. You can replace this with data from an analog pin or your sensor.</p>
<p>Type any character to terminate the example. Memory usage information will be printed.</p>
<h3><a class="anchor" id="delay_jitter"></a>
Delay Jitter Time</h3>
<p>The chJitter.ino example delays for one tick and measures the time difference in micros between delay calls.</p>
<p>The min and max times are printed by a lower priority task.</p>
<h3><a class="anchor" id="isr_semaphore"></a>
Task Scheduling from an Interrupt Service Routine</h3>
<p>The chIsrSemaphore.ino example demonstrates how a handler task can be triggered from an ISR by using a binary semaphore.</p>
<h3><a class="anchor" id="mail_pool"></a>
Mail and Memory Pool</h3>
<p>The chMailPool.ino example demonstrates use of a memory pool and mailboxes with two senders and one receiver.</p>
<h3><a class="anchor" id="mutex_print"></a>
Mutex Protecting Serial</h3>
<p>The chMutex.ino example shows how to protect a shared resource. In this case the mutex is used to share Serial between three threads. The mutex prevents print calls from the three threads from being scrambled.</p>
<h3><a class="anchor" id="round_robin"></a>
Round Robin Scheduling</h3>
<p>chRoundRobin.ino is a very simple demonstration of two tasks running in round robin mode.</p>
<h3><a class="anchor" id="counting_Semaphore"></a>
Counting Semaphore</h3>
<p>chSemaphore.ino demonstrates use of a counting semaphore by three tasks. Execution is restrict execution of at most two tasks in one region of code. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Wed May 29 2013 07:23:41 for ChibiOS/RT by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
